#!/usr/bin/env swift

/*
The MIT License (MIT)

Copyright (c) 2016 Ilya Puchka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import Cocoa
import AppKit.NSColor

let description = "clrex generates UIColor factory methods from clr files. By default will lookup ~/Library/Colors folder and will generate file Colors.generated.swift in current folder."
let usage = "Usage: clrex [-i PATH_TO_CLR_FILES_DIR] [-o PATH_TO_OUTPUT_FILE] [-p ios|osx]"
let example = "Example: clrex -i ~/Library/Colors/ -o ./Colors.swift -p osx --setup"
let note = "// This is a generated file, do not edit!\n// Generated by clrex, see https://github.com/ilyapuchka/clrex"

print(description, usage, example, separator: "\n")

//MARK: - Code generation

class NamedColor {
    let name: String
    let color: NSColor
    
    init(name: String, color: NSColor) {
        self.name = name
        self.color = color
    }
    
    init(key: String, color: NSColor) {
        self.name = colorNameForKey(key: key)
        self.color = color
    }
    
    func toTemplate(platform: Platform) -> String {
        return String(format: platform.methodTemplate, name, color.toTemplate(platform: platform))
    }
    
}

extension NSColor {
    
    func toTemplate(platform: Platform) -> String {
        return String(format: platform.valueTemplate, redComponent, greenComponent, blueComponent, alphaComponent)
    }
    
}

extension NSColorList {
    
    func toTemplate(platform: Platform) -> String {
        return String(format: platform.namespaceTemplate, name!, allNamedColors.toTemplate(platform: platform))
    }

}

extension Array where Element: NSColorList {
    
    func toTemplate(platform: Platform) -> String {
        return note + self
            .map({ $0.toTemplate(platform: platform) })
            .reduce(platform.importTemplate, +)
    }
    
}

extension Array where Element: NamedColor {
    func toTemplate(platform: Platform) -> String {
        return self
            .map({ $0.toTemplate(platform: platform) })
            .reduce("", +)
    }
}

//MARK: - Helpers

extension NSColor {
    
    var rgbColor: NSColor? {
        return usingColorSpaceName(NSCalibratedRGBColorSpace)
    }
    
    convenience init?(hex: String) {
        var hex = hex
        if hex.hasPrefix("#") {
            hex = String(hex.characters.dropFirst())
        }
        if hex.characters.count < 7 {
            hex = hex + "ff"
        }
        
        var colorCode = UInt32()
        
        let scanner = Scanner(string: hex)
        if scanner.scanHexInt32(&colorCode) {
            let redByte = CGFloat((colorCode & 0xff000000) >> 24)/255
            let greenByte = CGFloat((colorCode & 0x00ff0000) >> 16)/255
            let blueByte =  CGFloat((colorCode & 0xff00) >> 8)/255
            let alphaByte =  CGFloat((colorCode & 0xff))/255
            self.init(colorSpace: NSColorSpace.genericRGB, components: [redByte, greenByte, blueByte, alphaByte], count: 4)
        } else {
            return nil
        }
    }
}

extension NSColorList {
    
    var allNamedColors: [NamedColor] {
        return allKeys.flatMap(self.namedColorWithKey)
    }
    
    func namedColorWithKey(key: String) -> NamedColor? {
        return color(withKey: key)?.rgbColor.map({ NamedColor(key: key, color: $0) })
    }
    
    convenience init?(filePath: String) {
        guard isColorListFile(fileName: filePath) else { return nil }
        
        let listName = filePath.nsString.lastPathComponent.nsString.deletingPathExtension
        self.init(name: listName, fromFile: filePath)
    }

}

func colorNameForKey(key: String) -> String {
    let suffix = "Color"
    var name = key
        .replacingOccurrences(of: " ", with: "")
        .firstLetterLowercasedString
        .replacingOccurrences(of: "color", with: suffix)
    
    if !name.hasSuffix(suffix) {
        name += suffix
    }
    return name
}

func isColorListFile(fileName: String) -> Bool {
    return fileName.nsString.pathExtension.lowercased() == "clr"
}

extension FileManager {
    
    func fullContentsPathsOfDirectory(at path: String) throws -> [String] {
        return try contentsOfDirectory(atPath: path).map(path.nsString.appendingPathComponent)
    }

    func colorLists(at path: String) throws -> [NSColorList] {
        return try fullContentsPathsOfDirectory(at: path).flatMap(NSColorList.init(filePath:))
    }

}

extension Collection where Index: Comparable {
    subscript(safe index: Index) -> Iterator.Element? {
        guard index >= startIndex && index < endIndex else { return nil }
        return self[index]
    }
    
}

extension Collection where Iterator.Element: Equatable, Index: Comparable & Strideable {
    subscript(next element: Iterator.Element) -> Iterator.Element? {
        guard let index = self.index(of: element) else { return nil }
        return self[safe: index.advanced(by: 1)]
    }
}

extension String {
    var nsString: NSString { return self as NSString }
    
    var firstLetterLowercasedString: String {
        guard !isEmpty else { return self }
        return String(self[startIndex]).lowercased() + self[characters.index(startIndex, offsetBy: 1)..<endIndex]
    }
}

//MARK: - Templates

protocol Template {
    var module: String { get }
    var type: String { get }
    var value: String { get }
}

struct OSX: Template {
    let module  = "AppKit"
    let type    = "NSColor"
    let value   = "NSColor(calibratedRed: %f, green: %f, blue: %f, alpha: %f)"
}

struct iOS: Template {
    let module  = "UIKit"
    let type    = "UIColor"
    let value   = "UIColor(red: %f, green: %f, blue: %f, alpha: %f)"
}

enum Platform: String {
    case osx
    case ios
    
    var template: Template {
        switch self {
        case .osx: return OSX()
        case .ios: return iOS()
        }
    }
    
    var importTemplate: String {
        return "\n\nimport \(template.module)\n\n"
    }
    
    var methodTemplate: String {
        return "  static func %@() -> \(template.type) {\n    return %@\n  }\n\n"
    }
    
    var valueTemplate: String {
        return template.value
    }
    
    var namespaceTemplate: String {
        return "enum %@ {\n\n%@}\n\n"
    }
}

//MARK: - Input arguments

extension Process {
    
    static var info: ProcessInfo {
        return ProcessInfo.processInfo
    }
    
    static var scriptInputFilesCount: Int {
        return info.environment["SCRIPT_INPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptInputFiles: [String] {
        return (0..<scriptInputFilesCount).flatMap(scriptInputFile)
    }
    
    static func scriptInputFile(i: Int) -> String? {
        return info.environment["SCRIPT_INPUT_FILE_\(i)"]
    }
    
    static var scriptOutputFilesCount: Int {
        return info.environment["SCRIPT_OUTPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptOutputFiles: [String] {
        return (0..<scriptOutputFilesCount).flatMap(scriptOutputFile)
    }
    
    static func scriptOutputFile(i: Int) -> String? {
        return info.environment["SCRIPT_OUTPUT_FILE_\(i)"]
    }
    
    static func platform() -> Platform {
        return info.environment["PLATFORM_NAME"] == "macosx" ? .osx : .ios
    }
    
    static var argInput: String? {
        return info.arguments[next: "-i"]
    }
    
    static var argOutput: String? {
        return info.arguments[next: "-o"]
    }
    
    static var argPlatform: String? {
        return info.arguments[next: "-p"]
    }
    
    static var argSetup: Bool {
        return info.arguments.contains("--setup")
    }
    
    static var argAdd: (paletteName: String, colorName: String, colorHEX: String)? {
        guard let paletteName = info.arguments[next: "add"] else { return nil }
        guard let colorName = info.arguments[next: paletteName] else { return nil }
        guard let colorHEX = info.arguments[next: colorName] else { return nil }
        return (paletteName, colorName, colorHEX)
    }
    
    static var argDelete: (paletteName: String, colorName: String)? {
        guard let paletteName = info.arguments[next: "delete"] else { return nil }
        guard let colorName = info.arguments[next: paletteName] else { return nil }
        return (paletteName, colorName)
    }
    
}

//MARK: - Main

func systemColorsPath() -> String {
    guard let libraryDir = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.libraryDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).first else {
        fatalError("Failed to locate ~/Library")
    }
    
    return libraryDir.nsString.appendingPathComponent("Colors")
}

let colorsPath = Process.argInput ?? Process.scriptInputFiles.first ?? systemColorsPath()
let destinationPath = Process.argOutput ?? Process.scriptOutputFiles.first ?? "Colors.generated.swift"
let platform = Process.argPlatform.flatMap(Platform.init) ?? Process.platform()

do {
    let fm = FileManager.default
    print("Reading from \(colorsPath)")
    var lists = try fm.colorLists(at: colorsPath)
    if let add = Process.argAdd {
        let fileName = colorsPath
            .nsString.appendingPathComponent(add.paletteName)
            .nsString.appendingPathExtension("clr")!
        
        let list = NSColorList(filePath: fileName) ?? NSColorList(name: add.paletteName)
        lists = [list]
        if let color = NSColor(hex: add.colorHEX) {
            list.insertColor(color, key: add.colorName, at: 0)
            list.write(toFile: fileName)
        }
    } else if let delete = Process.argDelete {
        lists = []
        let fileName = colorsPath
            .nsString.appendingPathComponent(delete.paletteName)
            .nsString.appendingPathExtension("clr")!
        
        if let list = NSColorList(filePath: fileName) {
            list.removeColor(withKey: delete.colorName)
            list.write(toFile: fileName)
        }
    } else if !lists.isEmpty {
        print("Found palettes: \(lists.count)")
        let content = lists.toTemplate(platform: platform)
        print("Writing to \(destinationPath)")
        try content.write(toFile: destinationPath, atomically: true, encoding: String.Encoding.utf8)
    }
    
    if Process.argSetup {
        for list in lists {
            list.write(toFile: nil)
        }
    }
}
catch {
    fatalError(String(describing: error))
}


