#!/usr/bin/env swift

import Cocoa
import AppKit.NSColor

extension NSColor {
    
    func toTemplate() -> String {
        let template = "UIColor(red: %f, green: %f, blue: %f, alpha: %f)"
        return String(format: template, redComponent, greenComponent, blueComponent, alphaComponent)
    }
    
    var rgbColor: NSColor? {
        return colorUsingColorSpaceName(NSDeviceRGBColorSpace)
    }
    
}

extension NSColorList {
    
    var rgbColors: [(String, NSColor)] {
        return allKeys.flatMap({ key in
            self.colorWithKey(key)?.rgbColor.map({ color in
                return (self.colorNameForKey(key), color)
            })
        })
    }
    
    func toTemplate() -> String {
        let template = "  static func %@() -> UIColor {\n    return %@\n  }\n\n"
        return rgbColors
            .map { String(format: template, $0.0, $0.1.toTemplate()) }
            .reduce("", combine: +)
    }
    
    func colorNameForKey(key: String) -> String {
        var colorName = key
            .stringByReplacingOccurrencesOfString(" ", withString: "")
            .lowercaseString
            .stringByReplacingOccurrencesOfString("color", withString: "Color")
        
        if !colorName.hasSuffix("Color") {
            colorName += "Color"
        }
        return colorName
    }
    
    convenience init?(filePath: String) {
        guard isColorListFile(filePath) else { return nil }

        let listName = filePath.nsString.lastPathComponent.nsString.stringByDeletingPathExtension
        self.init(name: listName, fromFile: filePath)
    }

}

func isColorListFile(fileName: String) -> Bool {
    return fileName.nsString.pathExtension.lowercaseString == "clr"
}

extension Array where Element: NSColorList {
    
    func toTemplate() -> String {
        let template = "enum %@ {\n\n%@}\n"
        return map({ String(format: template, $0.name!, $0.toTemplate()) })
            .reduce("//AUTOGENERATED FILE, DO NOT EDIT\n\nimport UIKit\n\n", combine: +)
    }
    
}

extension NSFileManager {
    
    func fullContentsPathsOfDirectoryAtPath(path: String) throws -> [String] {
        return try contentsOfDirectoryAtPath(path).map({
            path.nsString.stringByAppendingPathComponent($0)
        })
    }

    func colorListsAtPath(path: String) throws -> [NSColorList] {
        return try fullContentsPathsOfDirectoryAtPath(path).flatMap({ NSColorList(filePath: $0) })
    }

}

extension CollectionType where Index: Comparable {
    subscript(safe index: Index) -> Generator.Element? {
        guard index >= startIndex && index < endIndex else {
            return nil
        }
        
        return self[index]
    }
    
}

extension CollectionType where Generator.Element: Equatable, Index: Comparable {
    subscript(next element: Generator.Element) -> Generator.Element? {
        guard let index = self.indexOf(element) else { return nil }
        return self[safe: index.advancedBy(1)]
    }
}

extension String {
    var nsString: NSString { return self as NSString }
}

extension Process {
    
    static var info: NSProcessInfo {
        return NSProcessInfo.processInfo()
    }
    
    static var scriptInputFilesCount: Int {
        return info.environment["SCRIPT_INPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptInputFiles: [String] {
        return (0..<scriptInputFilesCount).flatMap({ self.info.environment["SCRIPT_INPUT_FILE_\($0)"] })
    }
    
    static var scriptOutputFilesCount: Int {
        return info.environment["SCRIPT_OUTPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptOutputFiles: [String] {
        return (0..<scriptOutputFilesCount).flatMap({ self.info.environment["SCRIPT_OUTPUT_FILE_\($0)"] })
    }
    
    static var argInput: String? {
        return Process.arguments[next: "-i"]
    }
    
    static var argOutput: String? {
        return Process.arguments[next: "-o"]
    }

}

func systemColorsPath() -> String {
    guard let libraryDir = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.LibraryDirectory, NSSearchPathDomainMask.UserDomainMask, true).first else {
        fatalError("Failed to locate ~/Library")
    }
    
    return libraryDir.nsString.stringByAppendingPathComponent("Colors")
}

let colorsPath = Process.argInput ?? Process.scriptInputFiles.first ?? systemColorsPath()
let destinationPath = Process.argOutput ?? Process.scriptOutputFiles.first ?? "Colors.generated.swift"

do {
    let fm = NSFileManager.defaultManager()
    print("Reading from \(colorsPath)")
    let lists = try fm.colorListsAtPath(colorsPath)
    let content = lists.toTemplate()
    print("Writing to \(destinationPath)")
    try content.writeToFile(destinationPath, atomically: true, encoding: NSUTF8StringEncoding)
}
catch {
    fatalError(String(error))
}


