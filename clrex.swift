#!/usr/bin/env swift

/*
The MIT License (MIT)

Copyright (c) 2016 Ilya Puchka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import Cocoa
import AppKit.NSColor

let description = "clrex generates UIColor factory methods from clr files. By default will lookup ~/Library/Colors folder and will generate file Colors.generated.swift in current folder."
let usage = "Usage: clrex [-i PATH_TO_CLR_FILES_DIR] [-o PATH_TO_OUTPUT_FILE] [-p ios|osx]"
let example = "Example: clrex -i ~/Library/Colors/ -o ./Colors.swift -p osx"
let note = "// This is a generated file, do not edit!\n// Generated by clrex, see https://github.com/ilyapuchka/clrex"

print(description, usage, example, separator: "\n")

extension NSColor {
    
    func toTemplate(platform: Platform) -> String {
        return String(format: platform.valueTemplate, redComponent, greenComponent, blueComponent, alphaComponent)
    }
    
    var rgbColor: NSColor? {
        return colorUsingColorSpaceName(NSDeviceRGBColorSpace)
    }
    
}

extension NSColorList {
    
    var rgbColors: [(String, NSColor)] {
        return allKeys.flatMap({ key in
            self.colorWithKey(key)?.rgbColor.map({ color in
                return (self.colorNameForKey(key), color)
            })
        })
    }
    
    func toTemplate(platform: Platform) -> String {
        return rgbColors
            .map { String(format: platform.methodTemplate, $0.0, $0.1.toTemplate(platform)) }
            .reduce("", combine: +)
    }
    
    func colorNameForKey(key: String) -> String {
        let suffix = "Color"
        var colorName = key
            .stringByReplacingOccurrencesOfString(" ", withString: "")
            .lowercaseString
            .stringByReplacingOccurrencesOfString("color", withString: suffix)
        
        if !colorName.hasSuffix(suffix) {
            colorName += suffix
        }
        return colorName
    }
    
    convenience init?(filePath: String) {
        guard isColorListFile(filePath) else { return nil }

        let listName = filePath.nsString.lastPathComponent.nsString.stringByDeletingPathExtension
        self.init(name: listName, fromFile: filePath)
    }

}

func isColorListFile(fileName: String) -> Bool {
    return fileName.nsString.pathExtension.lowercaseString == "clr"
}

extension Array where Element: NSColorList {
    
    func toTemplate(platform: Platform) -> String {
        return note + map({ String(format: platform.namespaceTemplate, $0.name!, $0.toTemplate(platform)) })
            .reduce(platform.importTemplate, combine: +)
    }
    
}

extension NSFileManager {
    
    func fullContentsPathsOfDirectoryAtPath(path: String) throws -> [String] {
        return try contentsOfDirectoryAtPath(path).map({
            path.nsString.stringByAppendingPathComponent($0)
        })
    }

    func colorListsAtPath(path: String) throws -> [NSColorList] {
        return try fullContentsPathsOfDirectoryAtPath(path).flatMap({ NSColorList(filePath: $0) })
    }

}

extension CollectionType where Index: Comparable {
    subscript(safe index: Index) -> Generator.Element? {
        guard index >= startIndex && index < endIndex else {
            return nil
        }
        
        return self[index]
    }
    
}

extension CollectionType where Generator.Element: Equatable, Index: Comparable {
    subscript(next element: Generator.Element) -> Generator.Element? {
        guard let index = self.indexOf(element) else { return nil }
        return self[safe: index.advancedBy(1)]
    }
}

extension String {
    var nsString: NSString { return self as NSString }
}

extension Process {
    
    static var info: NSProcessInfo {
        return NSProcessInfo.processInfo()
    }
    
    static var scriptInputFilesCount: Int {
        return info.environment["SCRIPT_INPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptInputFiles: [String] {
        return (0..<scriptInputFilesCount).flatMap({ self.info.environment["SCRIPT_INPUT_FILE_\($0)"] })
    }
    
    static var scriptOutputFilesCount: Int {
        return info.environment["SCRIPT_OUTPUT_FILE_COUNT"].flatMap({Int($0)}) ?? 0
    }
    
    static var scriptOutputFiles: [String] {
        return (0..<scriptOutputFilesCount).flatMap({ self.info.environment["SCRIPT_OUTPUT_FILE_\($0)"] })
    }
    
    static var argInput: String? {
        return Process.arguments[next: "-i"]
    }
    
    static var argOutput: String? {
        return Process.arguments[next: "-o"]
    }
    
    static var argPlatform: String? {
        return Process.arguments[next: "-p"]
    }

}

protocol Template {
    var module: String { get }
    var type: String { get }
    var method: String { get }
}

struct OSX: Template {
    let module  = "AppKit"
    let type    = "NSColor"
    let method  = "NSColor(deviceRed: %f, green: %f, blue: %f, alpha: %f)"
}

struct iOS: Template {
    let module  = "UIKit"
    let type    = "UIColor"
    let method  = "UIColor(red: %f, green: %f, blue: %f, alpha: %f)"
}

enum Platform: String {
    case osx
    case ios
    
    var template: Template {
        switch self {
        case .osx: return OSX()
        case .ios: return iOS()
        }
    }
    
    var importTemplate: String {
        return "\n\nimport \(template.module)\n\n"
    }
    
    var methodTemplate: String {
        return "  static func %@() -> \(template.type) {\n    return %@\n  }\n\n"
    }
    
    var valueTemplate: String {
        return template.method
    }
    
    var namespaceTemplate: String {
        return "enum %@ {\n\n%@}\n"
    }
}

func systemColorsPath() -> String {
    guard let libraryDir = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.LibraryDirectory, NSSearchPathDomainMask.UserDomainMask, true).first else {
        fatalError("Failed to locate ~/Library")
    }
    
    return libraryDir.nsString.stringByAppendingPathComponent("Colors")
}

let colorsPath = Process.argInput ?? Process.scriptInputFiles.first ?? systemColorsPath()
let destinationPath = Process.argOutput ?? Process.scriptOutputFiles.first ?? "Colors.generated.swift"
let platform = Process.argPlatform.flatMap({ Platform(rawValue: $0) }) ?? Platform.ios

do {
    let fm = NSFileManager.defaultManager()
    print("Reading from \(colorsPath)")
    let lists = try fm.colorListsAtPath(colorsPath)
    print("Found palettes: \(lists.count)")
    if !lists.isEmpty {
        let content = lists.toTemplate(platform)
        print("Writing to \(destinationPath)")
        try content.writeToFile(destinationPath, atomically: true, encoding: NSUTF8StringEncoding)
    }
}
catch {
    fatalError(String(error))
}


